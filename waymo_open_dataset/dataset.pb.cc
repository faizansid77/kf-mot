// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: waymo_open_dataset/dataset.proto

#include "waymo_open_dataset/dataset.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Context_Stats_ObjectCount_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2flabel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Label_waymo_5fopen_5fdataset_2flabel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2flabel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Polygon2dProto_waymo_5fopen_5fdataset_2flabel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_waymo_5fopen_5fdataset_2fdataset_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Velocity_waymo_5fopen_5fdataset_2fdataset_2eproto;
namespace waymo {
namespace open_dataset {
class MatrixShapeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MatrixShape> _instance;
} _MatrixShape_default_instance_;
class MatrixFloatDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MatrixFloat> _instance;
} _MatrixFloat_default_instance_;
class MatrixInt32DefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MatrixInt32> _instance;
} _MatrixInt32_default_instance_;
class CameraNameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CameraName> _instance;
} _CameraName_default_instance_;
class LaserNameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LaserName> _instance;
} _LaserName_default_instance_;
class TransformDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Transform> _instance;
} _Transform_default_instance_;
class VelocityDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Velocity> _instance;
} _Velocity_default_instance_;
class CameraCalibrationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CameraCalibration> _instance;
} _CameraCalibration_default_instance_;
class LaserCalibrationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LaserCalibration> _instance;
} _LaserCalibration_default_instance_;
class Context_Stats_ObjectCountDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Context_Stats_ObjectCount> _instance;
} _Context_Stats_ObjectCount_default_instance_;
class Context_StatsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Context_Stats> _instance;
} _Context_Stats_default_instance_;
class ContextDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Context> _instance;
} _Context_default_instance_;
class RangeImageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RangeImage> _instance;
} _RangeImage_default_instance_;
class CameraImageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CameraImage> _instance;
} _CameraImage_default_instance_;
class CameraLabelsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CameraLabels> _instance;
} _CameraLabels_default_instance_;
class LaserDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Laser> _instance;
} _Laser_default_instance_;
class FrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Frame> _instance;
} _Frame_default_instance_;
}  // namespace open_dataset
}  // namespace waymo
static void InitDefaultsscc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_CameraCalibration_default_instance_;
    new (ptr) ::waymo::open_dataset::CameraCalibration();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::CameraCalibration::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_CameraImage_default_instance_;
    new (ptr) ::waymo::open_dataset::CameraImage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::CameraImage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_Velocity_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_CameraLabels_default_instance_;
    new (ptr) ::waymo::open_dataset::CameraLabels();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::CameraLabels::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_Label_waymo_5fopen_5fdataset_2flabel_2eproto.base,}};

static void InitDefaultsscc_info_CameraName_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_CameraName_default_instance_;
    new (ptr) ::waymo::open_dataset::CameraName();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::CameraName::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CameraName_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_CameraName_waymo_5fopen_5fdataset_2fdataset_2eproto}, {}};

static void InitDefaultsscc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_Context_default_instance_;
    new (ptr) ::waymo::open_dataset::Context();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::Context::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_Context_Stats_default_instance_;
    new (ptr) ::waymo::open_dataset::Context_Stats();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::Context_Stats::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_Context_Stats_ObjectCount_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_Context_Stats_ObjectCount_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_Context_Stats_ObjectCount_default_instance_;
    new (ptr) ::waymo::open_dataset::Context_Stats_ObjectCount();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::Context_Stats_ObjectCount::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Context_Stats_ObjectCount_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Context_Stats_ObjectCount_waymo_5fopen_5fdataset_2fdataset_2eproto}, {}};

static void InitDefaultsscc_info_Frame_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_Frame_default_instance_;
    new (ptr) ::waymo::open_dataset::Frame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::Frame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<7> scc_info_Frame_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsscc_info_Frame_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_Label_waymo_5fopen_5fdataset_2flabel_2eproto.base,
      &scc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
      &scc_info_Polygon2dProto_waymo_5fopen_5fdataset_2flabel_2eproto.base,}};

static void InitDefaultsscc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_Laser_default_instance_;
    new (ptr) ::waymo::open_dataset::Laser();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::Laser::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_LaserCalibration_default_instance_;
    new (ptr) ::waymo::open_dataset::LaserCalibration();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::LaserCalibration::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_LaserName_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_LaserName_default_instance_;
    new (ptr) ::waymo::open_dataset::LaserName();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::LaserName::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LaserName_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_LaserName_waymo_5fopen_5fdataset_2fdataset_2eproto}, {}};

static void InitDefaultsscc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_MatrixFloat_default_instance_;
    new (ptr) ::waymo::open_dataset::MatrixFloat();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::MatrixFloat::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_MatrixInt32_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_MatrixInt32_default_instance_;
    new (ptr) ::waymo::open_dataset::MatrixInt32();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::MatrixInt32::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MatrixInt32_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_MatrixInt32_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_MatrixShape_default_instance_;
    new (ptr) ::waymo::open_dataset::MatrixShape();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::MatrixShape::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto}, {}};

static void InitDefaultsscc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_RangeImage_default_instance_;
    new (ptr) ::waymo::open_dataset::RangeImage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::RangeImage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto}, {
      &scc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto.base,}};

static void InitDefaultsscc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_Transform_default_instance_;
    new (ptr) ::waymo::open_dataset::Transform();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::Transform::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto}, {}};

static void InitDefaultsscc_info_Velocity_waymo_5fopen_5fdataset_2fdataset_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::waymo::open_dataset::_Velocity_default_instance_;
    new (ptr) ::waymo::open_dataset::Velocity();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::waymo::open_dataset::Velocity::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Velocity_waymo_5fopen_5fdataset_2fdataset_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Velocity_waymo_5fopen_5fdataset_2fdataset_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_waymo_5fopen_5fdataset_2fdataset_2eproto[17];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_waymo_5fopen_5fdataset_2fdataset_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_waymo_5fopen_5fdataset_2fdataset_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_waymo_5fopen_5fdataset_2fdataset_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixShape, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixShape, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixShape, dims_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixFloat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixFloat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixFloat, data_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixFloat, shape_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixInt32, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixInt32, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixInt32, data_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::MatrixInt32, shape_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraName, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraName, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserName, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserName, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Transform, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Transform, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Transform, transform_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, v_x_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, v_y_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, v_z_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, w_x_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, w_y_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Velocity, w_z_),
  0,
  1,
  5,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, name_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, intrinsic_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, extrinsic_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, width_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, height_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraCalibration, rolling_shutter_direction_),
  1,
  ~0u,
  0,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserCalibration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserCalibration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserCalibration, name_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserCalibration, beam_inclinations_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserCalibration, beam_inclination_min_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserCalibration, beam_inclination_max_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::LaserCalibration, extrinsic_),
  3,
  ~0u,
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats_ObjectCount, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats_ObjectCount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats_ObjectCount, type_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats_ObjectCount, count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats, laser_object_counts_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats, camera_object_counts_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats, time_of_day_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats, location_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context_Stats, weather_),
  ~0u,
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context, name_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context, camera_calibrations_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context, laser_calibrations_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Context, stats_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::RangeImage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::RangeImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::RangeImage, range_image_compressed_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::RangeImage, camera_projection_compressed_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::RangeImage, range_image_pose_compressed_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::RangeImage, range_image_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, name_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, image_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, pose_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, velocity_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, pose_timestamp_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, shutter_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, camera_trigger_time_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraImage, camera_readout_done_time_),
  7,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraLabels, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraLabels, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraLabels, name_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::CameraLabels, labels_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Laser, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Laser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Laser, name_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Laser, ri_return1_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Laser, ri_return2_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, context_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, timestamp_micros_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, pose_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, images_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, lasers_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, laser_labels_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, projected_lidar_labels_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, camera_labels_),
  PROTOBUF_FIELD_OFFSET(::waymo::open_dataset::Frame, no_label_zones_),
  0,
  2,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 6, sizeof(::waymo::open_dataset::MatrixShape)},
  { 7, 14, sizeof(::waymo::open_dataset::MatrixFloat)},
  { 16, 23, sizeof(::waymo::open_dataset::MatrixInt32)},
  { 25, 30, sizeof(::waymo::open_dataset::CameraName)},
  { 30, 35, sizeof(::waymo::open_dataset::LaserName)},
  { 35, 41, sizeof(::waymo::open_dataset::Transform)},
  { 42, 53, sizeof(::waymo::open_dataset::Velocity)},
  { 59, 70, sizeof(::waymo::open_dataset::CameraCalibration)},
  { 76, 86, sizeof(::waymo::open_dataset::LaserCalibration)},
  { 91, 98, sizeof(::waymo::open_dataset::Context_Stats_ObjectCount)},
  { 100, 110, sizeof(::waymo::open_dataset::Context_Stats)},
  { 115, 124, sizeof(::waymo::open_dataset::Context)},
  { 128, 137, sizeof(::waymo::open_dataset::RangeImage)},
  { 141, 154, sizeof(::waymo::open_dataset::CameraImage)},
  { 162, 169, sizeof(::waymo::open_dataset::CameraLabels)},
  { 171, 179, sizeof(::waymo::open_dataset::Laser)},
  { 182, 196, sizeof(::waymo::open_dataset::Frame)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_MatrixShape_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_MatrixFloat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_MatrixInt32_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_CameraName_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_LaserName_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_Transform_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_Velocity_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_CameraCalibration_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_LaserCalibration_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_Context_Stats_ObjectCount_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_Context_Stats_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_Context_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_RangeImage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_CameraImage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_CameraLabels_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_Laser_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::waymo::open_dataset::_Frame_default_instance_),
};

const char descriptor_table_protodef_waymo_5fopen_5fdataset_2fdataset_2eproto[] =
  "\n waymo_open_dataset/dataset.proto\022\022waym"
  "o.open_dataset\032\036waymo_open_dataset/label"
  ".proto\"\033\n\013MatrixShape\022\014\n\004dims\030\001 \003(\005\"O\n\013M"
  "atrixFloat\022\020\n\004data\030\001 \003(\002B\002\020\001\022.\n\005shape\030\002 "
  "\001(\0132\037.waymo.open_dataset.MatrixShape\"O\n\013"
  "MatrixInt32\022\020\n\004data\030\001 \003(\005B\002\020\001\022.\n\005shape\030\002"
  " \001(\0132\037.waymo.open_dataset.MatrixShape\"l\n"
  "\nCameraName\"^\n\004Name\022\013\n\007UNKNOWN\020\000\022\t\n\005FRON"
  "T\020\001\022\016\n\nFRONT_LEFT\020\002\022\017\n\013FRONT_RIGHT\020\003\022\r\n\t"
  "SIDE_LEFT\020\004\022\016\n\nSIDE_RIGHT\020\005\"]\n\tLaserName"
  "\"P\n\004Name\022\013\n\007UNKNOWN\020\000\022\007\n\003TOP\020\001\022\t\n\005FRONT\020"
  "\002\022\r\n\tSIDE_LEFT\020\003\022\016\n\nSIDE_RIGHT\020\004\022\010\n\004REAR"
  "\020\005\"\036\n\tTransform\022\021\n\ttransform\030\001 \003(\001\"X\n\010Ve"
  "locity\022\013\n\003v_x\030\001 \001(\002\022\013\n\003v_y\030\002 \001(\002\022\013\n\003v_z\030"
  "\003 \001(\002\022\013\n\003w_x\030\004 \001(\001\022\013\n\003w_y\030\005 \001(\001\022\013\n\003w_z\030\006"
  " \001(\001\"\243\003\n\021CameraCalibration\0221\n\004name\030\001 \001(\016"
  "2#.waymo.open_dataset.CameraName.Name\022\021\n"
  "\tintrinsic\030\002 \003(\001\0220\n\textrinsic\030\003 \001(\0132\035.wa"
  "ymo.open_dataset.Transform\022\r\n\005width\030\004 \001("
  "\005\022\016\n\006height\030\005 \001(\005\022g\n\031rolling_shutter_dir"
  "ection\030\006 \001(\0162D.waymo.open_dataset.Camera"
  "Calibration.RollingShutterReadOutDirecti"
  "on\"\215\001\n\036RollingShutterReadOutDirection\022\013\n"
  "\007UNKNOWN\020\000\022\021\n\rTOP_TO_BOTTOM\020\001\022\021\n\rLEFT_TO"
  "_RIGHT\020\002\022\021\n\rBOTTOM_TO_TOP\020\003\022\021\n\rRIGHT_TO_"
  "LEFT\020\004\022\022\n\016GLOBAL_SHUTTER\020\005\"\315\001\n\020LaserCali"
  "bration\0220\n\004name\030\001 \001(\0162\".waymo.open_datas"
  "et.LaserName.Name\022\031\n\021beam_inclinations\030\002"
  " \003(\001\022\034\n\024beam_inclination_min\030\003 \001(\001\022\034\n\024be"
  "am_inclination_max\030\004 \001(\001\0220\n\textrinsic\030\005 "
  "\001(\0132\035.waymo.open_dataset.Transform\"\366\003\n\007C"
  "ontext\022\014\n\004name\030\001 \001(\t\022B\n\023camera_calibrati"
  "ons\030\002 \003(\0132%.waymo.open_dataset.CameraCal"
  "ibration\022@\n\022laser_calibrations\030\003 \003(\0132$.w"
  "aymo.open_dataset.LaserCalibration\0220\n\005st"
  "ats\030\004 \001(\0132!.waymo.open_dataset.Context.S"
  "tats\032\244\002\n\005Stats\022J\n\023laser_object_counts\030\001 "
  "\003(\0132-.waymo.open_dataset.Context.Stats.O"
  "bjectCount\022K\n\024camera_object_counts\030\005 \003(\013"
  "2-.waymo.open_dataset.Context.Stats.Obje"
  "ctCount\022\023\n\013time_of_day\030\002 \001(\t\022\020\n\010location"
  "\030\003 \001(\t\022\017\n\007weather\030\004 \001(\t\032J\n\013ObjectCount\022,"
  "\n\004type\030\001 \001(\0162\036.waymo.open_dataset.Label."
  "Type\022\r\n\005count\030\002 \001(\005\"\261\001\n\nRangeImage\022\036\n\026ra"
  "nge_image_compressed\030\002 \001(\014\022$\n\034camera_pro"
  "jection_compressed\030\003 \001(\014\022#\n\033range_image_"
  "pose_compressed\030\004 \001(\014\0228\n\013range_image\030\001 \001"
  "(\0132\037.waymo.open_dataset.MatrixFloatB\002\030\001\""
  "\224\002\n\013CameraImage\0221\n\004name\030\001 \001(\0162#.waymo.op"
  "en_dataset.CameraName.Name\022\r\n\005image\030\002 \001("
  "\014\022+\n\004pose\030\003 \001(\0132\035.waymo.open_dataset.Tra"
  "nsform\022.\n\010velocity\030\004 \001(\0132\034.waymo.open_da"
  "taset.Velocity\022\026\n\016pose_timestamp\030\005 \001(\001\022\017"
  "\n\007shutter\030\006 \001(\001\022\033\n\023camera_trigger_time\030\007"
  " \001(\001\022 \n\030camera_readout_done_time\030\010 \001(\001\"l"
  "\n\014CameraLabels\0221\n\004name\030\001 \001(\0162#.waymo.ope"
  "n_dataset.CameraName.Name\022)\n\006labels\030\002 \003("
  "\0132\031.waymo.open_dataset.Label\"\241\001\n\005Laser\0220"
  "\n\004name\030\001 \001(\0162\".waymo.open_dataset.LaserN"
  "ame.Name\0222\n\nri_return1\030\002 \001(\0132\036.waymo.ope"
  "n_dataset.RangeImage\0222\n\nri_return2\030\003 \001(\013"
  "2\036.waymo.open_dataset.RangeImage\"\300\003\n\005Fra"
  "me\022,\n\007context\030\001 \001(\0132\033.waymo.open_dataset"
  ".Context\022\030\n\020timestamp_micros\030\002 \001(\003\022+\n\004po"
  "se\030\003 \001(\0132\035.waymo.open_dataset.Transform\022"
  "/\n\006images\030\004 \003(\0132\037.waymo.open_dataset.Cam"
  "eraImage\022)\n\006lasers\030\005 \003(\0132\031.waymo.open_da"
  "taset.Laser\022/\n\014laser_labels\030\006 \003(\0132\031.waym"
  "o.open_dataset.Label\022@\n\026projected_lidar_"
  "labels\030\t \003(\0132 .waymo.open_dataset.Camera"
  "Labels\0227\n\rcamera_labels\030\010 \003(\0132 .waymo.op"
  "en_dataset.CameraLabels\022:\n\016no_label_zone"
  "s\030\007 \003(\0132\".waymo.open_dataset.Polygon2dPr"
  "oto"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_deps[1] = {
  &::descriptor_table_waymo_5fopen_5fdataset_2flabel_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_sccs[17] = {
  &scc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_CameraName_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_Context_Stats_ObjectCount_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_Frame_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_LaserName_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_MatrixInt32_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
  &scc_info_Velocity_waymo_5fopen_5fdataset_2fdataset_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_once;
static bool descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto = {
  &descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_initialized, descriptor_table_protodef_waymo_5fopen_5fdataset_2fdataset_2eproto, "waymo_open_dataset/dataset.proto", 2923,
  &descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_once, descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_sccs, descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto_deps, 17, 1,
  schemas, file_default_instances, TableStruct_waymo_5fopen_5fdataset_2fdataset_2eproto::offsets,
  file_level_metadata_waymo_5fopen_5fdataset_2fdataset_2eproto, 17, file_level_enum_descriptors_waymo_5fopen_5fdataset_2fdataset_2eproto, file_level_service_descriptors_waymo_5fopen_5fdataset_2fdataset_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_waymo_5fopen_5fdataset_2fdataset_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto), true);
namespace waymo {
namespace open_dataset {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraName_Name_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto);
  return file_level_enum_descriptors_waymo_5fopen_5fdataset_2fdataset_2eproto[0];
}
bool CameraName_Name_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CameraName_Name CameraName::UNKNOWN;
constexpr CameraName_Name CameraName::FRONT;
constexpr CameraName_Name CameraName::FRONT_LEFT;
constexpr CameraName_Name CameraName::FRONT_RIGHT;
constexpr CameraName_Name CameraName::SIDE_LEFT;
constexpr CameraName_Name CameraName::SIDE_RIGHT;
constexpr CameraName_Name CameraName::Name_MIN;
constexpr CameraName_Name CameraName::Name_MAX;
constexpr int CameraName::Name_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LaserName_Name_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto);
  return file_level_enum_descriptors_waymo_5fopen_5fdataset_2fdataset_2eproto[1];
}
bool LaserName_Name_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaserName_Name LaserName::UNKNOWN;
constexpr LaserName_Name LaserName::TOP;
constexpr LaserName_Name LaserName::FRONT;
constexpr LaserName_Name LaserName::SIDE_LEFT;
constexpr LaserName_Name LaserName::SIDE_RIGHT;
constexpr LaserName_Name LaserName::REAR;
constexpr LaserName_Name LaserName::Name_MIN;
constexpr LaserName_Name LaserName::Name_MAX;
constexpr int LaserName::Name_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraCalibration_RollingShutterReadOutDirection_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_waymo_5fopen_5fdataset_2fdataset_2eproto);
  return file_level_enum_descriptors_waymo_5fopen_5fdataset_2fdataset_2eproto[2];
}
bool CameraCalibration_RollingShutterReadOutDirection_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::UNKNOWN;
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::TOP_TO_BOTTOM;
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::LEFT_TO_RIGHT;
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::BOTTOM_TO_TOP;
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::RIGHT_TO_LEFT;
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::GLOBAL_SHUTTER;
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::RollingShutterReadOutDirection_MIN;
constexpr CameraCalibration_RollingShutterReadOutDirection CameraCalibration::RollingShutterReadOutDirection_MAX;
constexpr int CameraCalibration::RollingShutterReadOutDirection_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void MatrixShape::InitAsDefaultInstance() {
}
class MatrixShape::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<MatrixShape>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MatrixShape::kDimsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MatrixShape::MatrixShape()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.MatrixShape)
}
MatrixShape::MatrixShape(const MatrixShape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.MatrixShape)
}

void MatrixShape::SharedCtor() {
}

MatrixShape::~MatrixShape() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.MatrixShape)
  SharedDtor();
}

void MatrixShape::SharedDtor() {
}

void MatrixShape::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MatrixShape& MatrixShape::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MatrixShape_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void MatrixShape::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.MatrixShape)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MatrixShape::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int32 dims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 8);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MatrixShape::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.MatrixShape)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 dims = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 8u, input, this->mutable_dims())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_dims())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.MatrixShape)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.MatrixShape)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MatrixShape::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.MatrixShape)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 dims = 1;
  for (int i = 0, n = this->dims_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      1, this->dims(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.MatrixShape)
}

::PROTOBUF_NAMESPACE_ID::uint8* MatrixShape::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.MatrixShape)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 dims = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteInt32ToArray(1, this->dims_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.MatrixShape)
  return target;
}

size_t MatrixShape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.MatrixShape)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 dims = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->dims_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->dims_size());
    total_size += data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatrixShape::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.MatrixShape)
  GOOGLE_DCHECK_NE(&from, this);
  const MatrixShape* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MatrixShape>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.MatrixShape)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.MatrixShape)
    MergeFrom(*source);
  }
}

void MatrixShape::MergeFrom(const MatrixShape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.MatrixShape)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
}

void MatrixShape::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.MatrixShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatrixShape::CopyFrom(const MatrixShape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.MatrixShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatrixShape::IsInitialized() const {
  return true;
}

void MatrixShape::Swap(MatrixShape* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MatrixShape::InternalSwap(MatrixShape* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dims_.InternalSwap(&other->dims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MatrixShape::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MatrixFloat::InitAsDefaultInstance() {
  ::waymo::open_dataset::_MatrixFloat_default_instance_._instance.get_mutable()->shape_ = const_cast< ::waymo::open_dataset::MatrixShape*>(
      ::waymo::open_dataset::MatrixShape::internal_default_instance());
}
class MatrixFloat::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<MatrixFloat>()._has_bits_);
  static const ::waymo::open_dataset::MatrixShape& shape(const MatrixFloat* msg);
  static void set_has_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::waymo::open_dataset::MatrixShape&
MatrixFloat::HasBitSetters::shape(const MatrixFloat* msg) {
  return *msg->shape_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MatrixFloat::kDataFieldNumber;
const int MatrixFloat::kShapeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MatrixFloat::MatrixFloat()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.MatrixFloat)
}
MatrixFloat::MatrixFloat(const MatrixFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_shape()) {
    shape_ = new ::waymo::open_dataset::MatrixShape(*from.shape_);
  } else {
    shape_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.MatrixFloat)
}

void MatrixFloat::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  shape_ = nullptr;
}

MatrixFloat::~MatrixFloat() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.MatrixFloat)
  SharedDtor();
}

void MatrixFloat::SharedDtor() {
  if (this != internal_default_instance()) delete shape_;
}

void MatrixFloat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MatrixFloat& MatrixFloat::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MatrixFloat_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void MatrixFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.MatrixFloat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(shape_ != nullptr);
    shape_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MatrixFloat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated float data = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13) {
          add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.MatrixShape shape = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_shape(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MatrixFloat::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.MatrixFloat)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float data = 1 [packed = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_data())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 10u, input, this->mutable_data())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.MatrixShape shape = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_shape()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.MatrixFloat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.MatrixFloat)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MatrixFloat::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.MatrixFloat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float data = 1 [packed = true];
  if (this->data_size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteTag(1, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_data_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatArray(
      this->data().data(), this->data_size(), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.MatrixShape shape = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::shape(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.MatrixFloat)
}

::PROTOBUF_NAMESPACE_ID::uint8* MatrixFloat::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.MatrixFloat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float data = 1 [packed = true];
  if (this->data_size() > 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteTagToArray(
      1,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream::WriteVarint32ToArray(
        _data_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteFloatNoTagToArray(this->data_, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.MatrixShape shape = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::shape(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.MatrixFloat)
  return target;
}

size_t MatrixFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.MatrixFloat)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float data = 1 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->data_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional .waymo.open_dataset.MatrixShape shape = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *shape_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatrixFloat::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.MatrixFloat)
  GOOGLE_DCHECK_NE(&from, this);
  const MatrixFloat* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MatrixFloat>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.MatrixFloat)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.MatrixFloat)
    MergeFrom(*source);
  }
}

void MatrixFloat::MergeFrom(const MatrixFloat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.MatrixFloat)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from.has_shape()) {
    mutable_shape()->::waymo::open_dataset::MatrixShape::MergeFrom(from.shape());
  }
}

void MatrixFloat::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.MatrixFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatrixFloat::CopyFrom(const MatrixFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.MatrixFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatrixFloat::IsInitialized() const {
  return true;
}

void MatrixFloat::Swap(MatrixFloat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MatrixFloat::InternalSwap(MatrixFloat* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.InternalSwap(&other->data_);
  swap(shape_, other->shape_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MatrixFloat::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MatrixInt32::InitAsDefaultInstance() {
  ::waymo::open_dataset::_MatrixInt32_default_instance_._instance.get_mutable()->shape_ = const_cast< ::waymo::open_dataset::MatrixShape*>(
      ::waymo::open_dataset::MatrixShape::internal_default_instance());
}
class MatrixInt32::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<MatrixInt32>()._has_bits_);
  static const ::waymo::open_dataset::MatrixShape& shape(const MatrixInt32* msg);
  static void set_has_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::waymo::open_dataset::MatrixShape&
MatrixInt32::HasBitSetters::shape(const MatrixInt32* msg) {
  return *msg->shape_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MatrixInt32::kDataFieldNumber;
const int MatrixInt32::kShapeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MatrixInt32::MatrixInt32()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.MatrixInt32)
}
MatrixInt32::MatrixInt32(const MatrixInt32& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_shape()) {
    shape_ = new ::waymo::open_dataset::MatrixShape(*from.shape_);
  } else {
    shape_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.MatrixInt32)
}

void MatrixInt32::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MatrixInt32_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  shape_ = nullptr;
}

MatrixInt32::~MatrixInt32() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.MatrixInt32)
  SharedDtor();
}

void MatrixInt32::SharedDtor() {
  if (this != internal_default_instance()) delete shape_;
}

void MatrixInt32::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MatrixInt32& MatrixInt32::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MatrixInt32_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void MatrixInt32::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.MatrixInt32)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(shape_ != nullptr);
    shape_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MatrixInt32::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int32 data = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8) {
          add_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.MatrixShape shape = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_shape(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MatrixInt32::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.MatrixInt32)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 data = 1 [packed = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_data())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 10u, input, this->mutable_data())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.MatrixShape shape = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_shape()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.MatrixInt32)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.MatrixInt32)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MatrixInt32::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.MatrixInt32)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 data = 1 [packed = true];
  if (this->data_size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteTag(1, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_data_cached_byte_size_.load(
        std::memory_order_relaxed));
  }
  for (int i = 0, n = this->data_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32NoTag(
      this->data(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.MatrixShape shape = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::shape(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.MatrixInt32)
}

::PROTOBUF_NAMESPACE_ID::uint8* MatrixInt32::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.MatrixInt32)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 data = 1 [packed = true];
  if (this->data_size() > 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteTagToArray(
      1,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream::WriteVarint32ToArray(
        _data_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->data_, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.MatrixShape shape = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::shape(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.MatrixInt32)
  return target;
}

size_t MatrixInt32::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.MatrixInt32)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 data = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->data_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional .waymo.open_dataset.MatrixShape shape = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *shape_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatrixInt32::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.MatrixInt32)
  GOOGLE_DCHECK_NE(&from, this);
  const MatrixInt32* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MatrixInt32>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.MatrixInt32)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.MatrixInt32)
    MergeFrom(*source);
  }
}

void MatrixInt32::MergeFrom(const MatrixInt32& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.MatrixInt32)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from.has_shape()) {
    mutable_shape()->::waymo::open_dataset::MatrixShape::MergeFrom(from.shape());
  }
}

void MatrixInt32::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.MatrixInt32)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatrixInt32::CopyFrom(const MatrixInt32& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.MatrixInt32)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatrixInt32::IsInitialized() const {
  return true;
}

void MatrixInt32::Swap(MatrixInt32* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MatrixInt32::InternalSwap(MatrixInt32* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.InternalSwap(&other->data_);
  swap(shape_, other->shape_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MatrixInt32::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CameraName::InitAsDefaultInstance() {
}
class CameraName::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<CameraName>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CameraName::CameraName()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.CameraName)
}
CameraName::CameraName(const CameraName& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.CameraName)
}

void CameraName::SharedCtor() {
}

CameraName::~CameraName() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.CameraName)
  SharedDtor();
}

void CameraName::SharedDtor() {
}

void CameraName::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CameraName& CameraName::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CameraName_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void CameraName::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.CameraName)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CameraName::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CameraName::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.CameraName)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.CameraName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.CameraName)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CameraName::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.CameraName)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.CameraName)
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraName::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.CameraName)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.CameraName)
  return target;
}

size_t CameraName::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.CameraName)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CameraName::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.CameraName)
  GOOGLE_DCHECK_NE(&from, this);
  const CameraName* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CameraName>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.CameraName)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.CameraName)
    MergeFrom(*source);
  }
}

void CameraName::MergeFrom(const CameraName& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.CameraName)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void CameraName::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.CameraName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraName::CopyFrom(const CameraName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.CameraName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraName::IsInitialized() const {
  return true;
}

void CameraName::Swap(CameraName* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CameraName::InternalSwap(CameraName* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraName::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LaserName::InitAsDefaultInstance() {
}
class LaserName::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<LaserName>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserName::LaserName()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.LaserName)
}
LaserName::LaserName(const LaserName& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.LaserName)
}

void LaserName::SharedCtor() {
}

LaserName::~LaserName() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.LaserName)
  SharedDtor();
}

void LaserName::SharedDtor() {
}

void LaserName::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LaserName& LaserName::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LaserName_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void LaserName::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.LaserName)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LaserName::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LaserName::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.LaserName)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.LaserName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.LaserName)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LaserName::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.LaserName)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.LaserName)
}

::PROTOBUF_NAMESPACE_ID::uint8* LaserName::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.LaserName)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.LaserName)
  return target;
}

size_t LaserName::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.LaserName)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaserName::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.LaserName)
  GOOGLE_DCHECK_NE(&from, this);
  const LaserName* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LaserName>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.LaserName)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.LaserName)
    MergeFrom(*source);
  }
}

void LaserName::MergeFrom(const LaserName& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.LaserName)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void LaserName::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.LaserName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserName::CopyFrom(const LaserName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.LaserName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserName::IsInitialized() const {
  return true;
}

void LaserName::Swap(LaserName* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserName::InternalSwap(LaserName* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LaserName::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Transform::InitAsDefaultInstance() {
}
class Transform::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Transform>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Transform::kTransformFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Transform::Transform()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.Transform)
}
Transform::Transform(const Transform& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      transform_(from.transform_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.Transform)
}

void Transform::SharedCtor() {
}

Transform::~Transform() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.Transform)
  SharedDtor();
}

void Transform::SharedDtor() {
}

void Transform::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Transform& Transform::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Transform_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void Transform::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.Transform)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  transform_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Transform::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated double transform = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_transform(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 9);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(mutable_transform(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Transform::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.Transform)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double transform = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (9 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_transform())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_transform())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.Transform)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.Transform)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Transform::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.Transform)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double transform = 1;
  for (int i = 0, n = this->transform_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(
      1, this->transform(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.Transform)
}

::PROTOBUF_NAMESPACE_ID::uint8* Transform::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.Transform)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double transform = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteDoubleToArray(1, this->transform_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.Transform)
  return target;
}

size_t Transform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.Transform)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double transform = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->transform_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->transform_size());
    total_size += data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Transform::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.Transform)
  GOOGLE_DCHECK_NE(&from, this);
  const Transform* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Transform>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.Transform)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.Transform)
    MergeFrom(*source);
  }
}

void Transform::MergeFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.Transform)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  transform_.MergeFrom(from.transform_);
}

void Transform::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.Transform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Transform::CopyFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.Transform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transform::IsInitialized() const {
  return true;
}

void Transform::Swap(Transform* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Transform::InternalSwap(Transform* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  transform_.InternalSwap(&other->transform_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Transform::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Velocity::InitAsDefaultInstance() {
}
class Velocity::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Velocity>()._has_bits_);
  static void set_has_v_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_v_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_v_z(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_w_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_w_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_w_z(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Velocity::kVXFieldNumber;
const int Velocity::kVYFieldNumber;
const int Velocity::kVZFieldNumber;
const int Velocity::kWXFieldNumber;
const int Velocity::kWYFieldNumber;
const int Velocity::kWZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Velocity::Velocity()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.Velocity)
}
Velocity::Velocity(const Velocity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&v_x_, &from.v_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&v_z_) -
    reinterpret_cast<char*>(&v_x_)) + sizeof(v_z_));
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.Velocity)
}

void Velocity::SharedCtor() {
  ::memset(&v_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&v_z_) -
      reinterpret_cast<char*>(&v_x_)) + sizeof(v_z_));
}

Velocity::~Velocity() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.Velocity)
  SharedDtor();
}

void Velocity::SharedDtor() {
}

void Velocity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Velocity& Velocity::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Velocity_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void Velocity::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.Velocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&v_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&v_z_) -
        reinterpret_cast<char*>(&v_x_)) + sizeof(v_z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Velocity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float v_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          HasBitSetters::set_has_v_x(&has_bits);
          v_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float v_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_v_y(&has_bits);
          v_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float v_z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_v_z(&has_bits);
          v_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional double w_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          HasBitSetters::set_has_w_x(&has_bits);
          w_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double w_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          HasBitSetters::set_has_w_y(&has_bits);
          w_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double w_z = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          HasBitSetters::set_has_w_z(&has_bits);
          w_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Velocity::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.Velocity)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float v_x = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_v_x(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &v_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float v_y = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_v_y(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &v_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float v_z = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_v_z(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &v_z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double w_x = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_w_x(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double w_y = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_w_y(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double w_z = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_w_z(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.Velocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.Velocity)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Velocity::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.Velocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float v_x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(1, this->v_x(), output);
  }

  // optional float v_y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->v_y(), output);
  }

  // optional float v_z = 3;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->v_z(), output);
  }

  // optional double w_x = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(4, this->w_x(), output);
  }

  // optional double w_y = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(5, this->w_y(), output);
  }

  // optional double w_z = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(6, this->w_z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.Velocity)
}

::PROTOBUF_NAMESPACE_ID::uint8* Velocity::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.Velocity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float v_x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->v_x(), target);
  }

  // optional float v_y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->v_y(), target);
  }

  // optional float v_z = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->v_z(), target);
  }

  // optional double w_x = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->w_x(), target);
  }

  // optional double w_y = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->w_y(), target);
  }

  // optional double w_z = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->w_z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.Velocity)
  return target;
}

size_t Velocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.Velocity)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional float v_x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float v_y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional double w_x = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double w_y = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double w_z = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional float v_z = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Velocity::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.Velocity)
  GOOGLE_DCHECK_NE(&from, this);
  const Velocity* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Velocity>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.Velocity)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.Velocity)
    MergeFrom(*source);
  }
}

void Velocity::MergeFrom(const Velocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.Velocity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      v_x_ = from.v_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      v_y_ = from.v_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      w_x_ = from.w_x_;
    }
    if (cached_has_bits & 0x00000008u) {
      w_y_ = from.w_y_;
    }
    if (cached_has_bits & 0x00000010u) {
      w_z_ = from.w_z_;
    }
    if (cached_has_bits & 0x00000020u) {
      v_z_ = from.v_z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Velocity::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.Velocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Velocity::CopyFrom(const Velocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.Velocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Velocity::IsInitialized() const {
  return true;
}

void Velocity::Swap(Velocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Velocity::InternalSwap(Velocity* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(v_x_, other->v_x_);
  swap(v_y_, other->v_y_);
  swap(w_x_, other->w_x_);
  swap(w_y_, other->w_y_);
  swap(w_z_, other->w_z_);
  swap(v_z_, other->v_z_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Velocity::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CameraCalibration::InitAsDefaultInstance() {
  ::waymo::open_dataset::_CameraCalibration_default_instance_._instance.get_mutable()->extrinsic_ = const_cast< ::waymo::open_dataset::Transform*>(
      ::waymo::open_dataset::Transform::internal_default_instance());
}
class CameraCalibration::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<CameraCalibration>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::waymo::open_dataset::Transform& extrinsic(const CameraCalibration* msg);
  static void set_has_extrinsic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rolling_shutter_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::waymo::open_dataset::Transform&
CameraCalibration::HasBitSetters::extrinsic(const CameraCalibration* msg) {
  return *msg->extrinsic_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CameraCalibration::kNameFieldNumber;
const int CameraCalibration::kIntrinsicFieldNumber;
const int CameraCalibration::kExtrinsicFieldNumber;
const int CameraCalibration::kWidthFieldNumber;
const int CameraCalibration::kHeightFieldNumber;
const int CameraCalibration::kRollingShutterDirectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CameraCalibration::CameraCalibration()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.CameraCalibration)
}
CameraCalibration::CameraCalibration(const CameraCalibration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      intrinsic_(from.intrinsic_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_extrinsic()) {
    extrinsic_ = new ::waymo::open_dataset::Transform(*from.extrinsic_);
  } else {
    extrinsic_ = nullptr;
  }
  ::memcpy(&name_, &from.name_,
    static_cast<size_t>(reinterpret_cast<char*>(&rolling_shutter_direction_) -
    reinterpret_cast<char*>(&name_)) + sizeof(rolling_shutter_direction_));
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.CameraCalibration)
}

void CameraCalibration::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  ::memset(&extrinsic_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rolling_shutter_direction_) -
      reinterpret_cast<char*>(&extrinsic_)) + sizeof(rolling_shutter_direction_));
}

CameraCalibration::~CameraCalibration() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.CameraCalibration)
  SharedDtor();
}

void CameraCalibration::SharedDtor() {
  if (this != internal_default_instance()) delete extrinsic_;
}

void CameraCalibration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CameraCalibration& CameraCalibration::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CameraCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void CameraCalibration::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.CameraCalibration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  intrinsic_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(extrinsic_ != nullptr);
    extrinsic_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&name_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rolling_shutter_direction_) -
        reinterpret_cast<char*>(&name_)) + sizeof(rolling_shutter_direction_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CameraCalibration::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.CameraName.Name name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::waymo::open_dataset::CameraName_Name_IsValid(val))) {
            set_name(static_cast<::waymo::open_dataset::CameraName_Name>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated double intrinsic = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_intrinsic(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 17);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(mutable_intrinsic(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.Transform extrinsic = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_extrinsic(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.CameraCalibration.RollingShutterReadOutDirection rolling_shutter_direction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::waymo::open_dataset::CameraCalibration_RollingShutterReadOutDirection_IsValid(val))) {
            set_rolling_shutter_direction(static_cast<::waymo::open_dataset::CameraCalibration_RollingShutterReadOutDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CameraCalibration::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.CameraCalibration)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.CameraName.Name name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::waymo::open_dataset::CameraName_Name_IsValid(value)) {
            set_name(static_cast< ::waymo::open_dataset::CameraName_Name >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double intrinsic = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (17 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 17u, input, this->mutable_intrinsic())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_intrinsic())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.Transform extrinsic = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_extrinsic()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 width = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_width(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 height = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_height(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.CameraCalibration.RollingShutterReadOutDirection rolling_shutter_direction = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::waymo::open_dataset::CameraCalibration_RollingShutterReadOutDirection_IsValid(value)) {
            set_rolling_shutter_direction(static_cast< ::waymo::open_dataset::CameraCalibration_RollingShutterReadOutDirection >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.CameraCalibration)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.CameraCalibration)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CameraCalibration::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.CameraCalibration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.CameraName.Name name = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->name(), output);
  }

  // repeated double intrinsic = 2;
  for (int i = 0, n = this->intrinsic_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(
      2, this->intrinsic(i), output);
  }

  // optional .waymo.open_dataset.Transform extrinsic = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::extrinsic(this), output);
  }

  // optional int32 width = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->width(), output);
  }

  // optional int32 height = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->height(), output);
  }

  // optional .waymo.open_dataset.CameraCalibration.RollingShutterReadOutDirection rolling_shutter_direction = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->rolling_shutter_direction(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.CameraCalibration)
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraCalibration::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.CameraCalibration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.CameraName.Name name = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->name(), target);
  }

  // repeated double intrinsic = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteDoubleToArray(2, this->intrinsic_, target);

  // optional .waymo.open_dataset.Transform extrinsic = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::extrinsic(this), target);
  }

  // optional int32 width = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->width(), target);
  }

  // optional int32 height = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->height(), target);
  }

  // optional .waymo.open_dataset.CameraCalibration.RollingShutterReadOutDirection rolling_shutter_direction = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->rolling_shutter_direction(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.CameraCalibration)
  return target;
}

size_t CameraCalibration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.CameraCalibration)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double intrinsic = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->intrinsic_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->intrinsic_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .waymo.open_dataset.Transform extrinsic = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extrinsic_);
    }

    // optional .waymo.open_dataset.CameraName.Name name = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->name());
    }

    // optional int32 width = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // optional int32 height = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->height());
    }

    // optional .waymo.open_dataset.CameraCalibration.RollingShutterReadOutDirection rolling_shutter_direction = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->rolling_shutter_direction());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CameraCalibration::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.CameraCalibration)
  GOOGLE_DCHECK_NE(&from, this);
  const CameraCalibration* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CameraCalibration>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.CameraCalibration)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.CameraCalibration)
    MergeFrom(*source);
  }
}

void CameraCalibration::MergeFrom(const CameraCalibration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.CameraCalibration)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  intrinsic_.MergeFrom(from.intrinsic_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_extrinsic()->::waymo::open_dataset::Transform::MergeFrom(from.extrinsic());
    }
    if (cached_has_bits & 0x00000002u) {
      name_ = from.name_;
    }
    if (cached_has_bits & 0x00000004u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000008u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000010u) {
      rolling_shutter_direction_ = from.rolling_shutter_direction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CameraCalibration::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.CameraCalibration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraCalibration::CopyFrom(const CameraCalibration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.CameraCalibration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraCalibration::IsInitialized() const {
  return true;
}

void CameraCalibration::Swap(CameraCalibration* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CameraCalibration::InternalSwap(CameraCalibration* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  intrinsic_.InternalSwap(&other->intrinsic_);
  swap(extrinsic_, other->extrinsic_);
  swap(name_, other->name_);
  swap(width_, other->width_);
  swap(height_, other->height_);
  swap(rolling_shutter_direction_, other->rolling_shutter_direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraCalibration::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LaserCalibration::InitAsDefaultInstance() {
  ::waymo::open_dataset::_LaserCalibration_default_instance_._instance.get_mutable()->extrinsic_ = const_cast< ::waymo::open_dataset::Transform*>(
      ::waymo::open_dataset::Transform::internal_default_instance());
}
class LaserCalibration::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<LaserCalibration>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_beam_inclination_min(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_beam_inclination_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::waymo::open_dataset::Transform& extrinsic(const LaserCalibration* msg);
  static void set_has_extrinsic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::waymo::open_dataset::Transform&
LaserCalibration::HasBitSetters::extrinsic(const LaserCalibration* msg) {
  return *msg->extrinsic_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaserCalibration::kNameFieldNumber;
const int LaserCalibration::kBeamInclinationsFieldNumber;
const int LaserCalibration::kBeamInclinationMinFieldNumber;
const int LaserCalibration::kBeamInclinationMaxFieldNumber;
const int LaserCalibration::kExtrinsicFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserCalibration::LaserCalibration()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.LaserCalibration)
}
LaserCalibration::LaserCalibration(const LaserCalibration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      beam_inclinations_(from.beam_inclinations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_extrinsic()) {
    extrinsic_ = new ::waymo::open_dataset::Transform(*from.extrinsic_);
  } else {
    extrinsic_ = nullptr;
  }
  ::memcpy(&beam_inclination_min_, &from.beam_inclination_min_,
    static_cast<size_t>(reinterpret_cast<char*>(&name_) -
    reinterpret_cast<char*>(&beam_inclination_min_)) + sizeof(name_));
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.LaserCalibration)
}

void LaserCalibration::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  ::memset(&extrinsic_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&name_) -
      reinterpret_cast<char*>(&extrinsic_)) + sizeof(name_));
}

LaserCalibration::~LaserCalibration() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.LaserCalibration)
  SharedDtor();
}

void LaserCalibration::SharedDtor() {
  if (this != internal_default_instance()) delete extrinsic_;
}

void LaserCalibration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LaserCalibration& LaserCalibration::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LaserCalibration_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void LaserCalibration::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.LaserCalibration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  beam_inclinations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(extrinsic_ != nullptr);
    extrinsic_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&beam_inclination_min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&name_) -
        reinterpret_cast<char*>(&beam_inclination_min_)) + sizeof(name_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LaserCalibration::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.LaserName.Name name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::waymo::open_dataset::LaserName_Name_IsValid(val))) {
            set_name(static_cast<::waymo::open_dataset::LaserName_Name>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated double beam_inclinations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_beam_inclinations(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 17);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(mutable_beam_inclinations(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double beam_inclination_min = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          HasBitSetters::set_has_beam_inclination_min(&has_bits);
          beam_inclination_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double beam_inclination_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          HasBitSetters::set_has_beam_inclination_max(&has_bits);
          beam_inclination_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.Transform extrinsic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_extrinsic(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LaserCalibration::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.LaserCalibration)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.LaserName.Name name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::waymo::open_dataset::LaserName_Name_IsValid(value)) {
            set_name(static_cast< ::waymo::open_dataset::LaserName_Name >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double beam_inclinations = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (17 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 17u, input, this->mutable_beam_inclinations())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_beam_inclinations())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double beam_inclination_min = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_beam_inclination_min(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &beam_inclination_min_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double beam_inclination_max = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_beam_inclination_max(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &beam_inclination_max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.Transform extrinsic = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_extrinsic()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.LaserCalibration)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.LaserCalibration)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LaserCalibration::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.LaserCalibration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.LaserName.Name name = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->name(), output);
  }

  // repeated double beam_inclinations = 2;
  for (int i = 0, n = this->beam_inclinations_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(
      2, this->beam_inclinations(i), output);
  }

  // optional double beam_inclination_min = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(3, this->beam_inclination_min(), output);
  }

  // optional double beam_inclination_max = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(4, this->beam_inclination_max(), output);
  }

  // optional .waymo.open_dataset.Transform extrinsic = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::extrinsic(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.LaserCalibration)
}

::PROTOBUF_NAMESPACE_ID::uint8* LaserCalibration::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.LaserCalibration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.LaserName.Name name = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->name(), target);
  }

  // repeated double beam_inclinations = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteDoubleToArray(2, this->beam_inclinations_, target);

  // optional double beam_inclination_min = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->beam_inclination_min(), target);
  }

  // optional double beam_inclination_max = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->beam_inclination_max(), target);
  }

  // optional .waymo.open_dataset.Transform extrinsic = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::extrinsic(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.LaserCalibration)
  return target;
}

size_t LaserCalibration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.LaserCalibration)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double beam_inclinations = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->beam_inclinations_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->beam_inclinations_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .waymo.open_dataset.Transform extrinsic = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extrinsic_);
    }

    // optional double beam_inclination_min = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double beam_inclination_max = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .waymo.open_dataset.LaserName.Name name = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->name());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaserCalibration::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.LaserCalibration)
  GOOGLE_DCHECK_NE(&from, this);
  const LaserCalibration* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LaserCalibration>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.LaserCalibration)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.LaserCalibration)
    MergeFrom(*source);
  }
}

void LaserCalibration::MergeFrom(const LaserCalibration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.LaserCalibration)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  beam_inclinations_.MergeFrom(from.beam_inclinations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_extrinsic()->::waymo::open_dataset::Transform::MergeFrom(from.extrinsic());
    }
    if (cached_has_bits & 0x00000002u) {
      beam_inclination_min_ = from.beam_inclination_min_;
    }
    if (cached_has_bits & 0x00000004u) {
      beam_inclination_max_ = from.beam_inclination_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      name_ = from.name_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LaserCalibration::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.LaserCalibration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserCalibration::CopyFrom(const LaserCalibration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.LaserCalibration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserCalibration::IsInitialized() const {
  return true;
}

void LaserCalibration::Swap(LaserCalibration* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserCalibration::InternalSwap(LaserCalibration* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  beam_inclinations_.InternalSwap(&other->beam_inclinations_);
  swap(extrinsic_, other->extrinsic_);
  swap(beam_inclination_min_, other->beam_inclination_min_);
  swap(beam_inclination_max_, other->beam_inclination_max_);
  swap(name_, other->name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LaserCalibration::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Context_Stats_ObjectCount::InitAsDefaultInstance() {
}
class Context_Stats_ObjectCount::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Context_Stats_ObjectCount>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Context_Stats_ObjectCount::kTypeFieldNumber;
const int Context_Stats_ObjectCount::kCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Context_Stats_ObjectCount::Context_Stats_ObjectCount()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.Context.Stats.ObjectCount)
}
Context_Stats_ObjectCount::Context_Stats_ObjectCount(const Context_Stats_ObjectCount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&type_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.Context.Stats.ObjectCount)
}

void Context_Stats_ObjectCount::SharedCtor() {
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&type_)) + sizeof(count_));
}

Context_Stats_ObjectCount::~Context_Stats_ObjectCount() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.Context.Stats.ObjectCount)
  SharedDtor();
}

void Context_Stats_ObjectCount::SharedDtor() {
}

void Context_Stats_ObjectCount::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Context_Stats_ObjectCount& Context_Stats_ObjectCount::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Context_Stats_ObjectCount_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void Context_Stats_ObjectCount::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.Context.Stats.ObjectCount)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&type_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Context_Stats_ObjectCount::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.Label.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::waymo::open_dataset::Label_Type_IsValid(val))) {
            set_type(static_cast<::waymo::open_dataset::Label_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Context_Stats_ObjectCount::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.Context.Stats.ObjectCount)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.Label.Type type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::waymo::open_dataset::Label_Type_IsValid(value)) {
            set_type(static_cast< ::waymo::open_dataset::Label_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 count = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.Context.Stats.ObjectCount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.Context.Stats.ObjectCount)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Context_Stats_ObjectCount::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.Context.Stats.ObjectCount)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.Label.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional int32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.Context.Stats.ObjectCount)
}

::PROTOBUF_NAMESPACE_ID::uint8* Context_Stats_ObjectCount::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.Context.Stats.ObjectCount)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.Label.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional int32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->count(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.Context.Stats.ObjectCount)
  return target;
}

size_t Context_Stats_ObjectCount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.Context.Stats.ObjectCount)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .waymo.open_dataset.Label.Type type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional int32 count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Context_Stats_ObjectCount::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.Context.Stats.ObjectCount)
  GOOGLE_DCHECK_NE(&from, this);
  const Context_Stats_ObjectCount* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Context_Stats_ObjectCount>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.Context.Stats.ObjectCount)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.Context.Stats.ObjectCount)
    MergeFrom(*source);
  }
}

void Context_Stats_ObjectCount::MergeFrom(const Context_Stats_ObjectCount& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.Context.Stats.ObjectCount)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Context_Stats_ObjectCount::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.Context.Stats.ObjectCount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Context_Stats_ObjectCount::CopyFrom(const Context_Stats_ObjectCount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.Context.Stats.ObjectCount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Context_Stats_ObjectCount::IsInitialized() const {
  return true;
}

void Context_Stats_ObjectCount::Swap(Context_Stats_ObjectCount* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Context_Stats_ObjectCount::InternalSwap(Context_Stats_ObjectCount* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
  swap(count_, other->count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Context_Stats_ObjectCount::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Context_Stats::InitAsDefaultInstance() {
}
class Context_Stats::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Context_Stats>()._has_bits_);
  static void set_has_time_of_day(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_weather(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Context_Stats::kLaserObjectCountsFieldNumber;
const int Context_Stats::kCameraObjectCountsFieldNumber;
const int Context_Stats::kTimeOfDayFieldNumber;
const int Context_Stats::kLocationFieldNumber;
const int Context_Stats::kWeatherFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Context_Stats::Context_Stats()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.Context.Stats)
}
Context_Stats::Context_Stats(const Context_Stats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      laser_object_counts_(from.laser_object_counts_),
      camera_object_counts_(from.camera_object_counts_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  time_of_day_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_time_of_day()) {
    time_of_day_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.time_of_day_);
  }
  location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_location()) {
    location_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.location_);
  }
  weather_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_weather()) {
    weather_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.weather_);
  }
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.Context.Stats)
}

void Context_Stats::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  time_of_day_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  weather_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Context_Stats::~Context_Stats() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.Context.Stats)
  SharedDtor();
}

void Context_Stats::SharedDtor() {
  time_of_day_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  location_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  weather_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Context_Stats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Context_Stats& Context_Stats::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Context_Stats_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void Context_Stats::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.Context.Stats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  laser_object_counts_.Clear();
  camera_object_counts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      time_of_day_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      location_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      weather_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Context_Stats::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .waymo.open_dataset.Context.Stats.ObjectCount laser_object_counts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_laser_object_counts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // optional string time_of_day = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_time_of_day(), ptr, ctx, "waymo.open_dataset.Context.Stats.time_of_day");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_location(), ptr, ctx, "waymo.open_dataset.Context.Stats.location");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string weather = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_weather(), ptr, ctx, "waymo.open_dataset.Context.Stats.weather");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.Context.Stats.ObjectCount camera_object_counts = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_camera_object_counts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Context_Stats::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.Context.Stats)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .waymo.open_dataset.Context.Stats.ObjectCount laser_object_counts = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_laser_object_counts()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string time_of_day = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_time_of_day()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->time_of_day().data(), static_cast<int>(this->time_of_day().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "waymo.open_dataset.Context.Stats.time_of_day");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string location = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->location().data(), static_cast<int>(this->location().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "waymo.open_dataset.Context.Stats.location");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string weather = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_weather()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->weather().data(), static_cast<int>(this->weather().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "waymo.open_dataset.Context.Stats.weather");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.Context.Stats.ObjectCount camera_object_counts = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_camera_object_counts()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.Context.Stats)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.Context.Stats)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Context_Stats::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.Context.Stats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .waymo.open_dataset.Context.Stats.ObjectCount laser_object_counts = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->laser_object_counts_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->laser_object_counts(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string time_of_day = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->time_of_day().data(), static_cast<int>(this->time_of_day().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.Stats.time_of_day");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->time_of_day(), output);
  }

  // optional string location = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), static_cast<int>(this->location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.Stats.location");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->location(), output);
  }

  // optional string weather = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->weather().data(), static_cast<int>(this->weather().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.Stats.weather");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->weather(), output);
  }

  // repeated .waymo.open_dataset.Context.Stats.ObjectCount camera_object_counts = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->camera_object_counts_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->camera_object_counts(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.Context.Stats)
}

::PROTOBUF_NAMESPACE_ID::uint8* Context_Stats::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.Context.Stats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .waymo.open_dataset.Context.Stats.ObjectCount laser_object_counts = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->laser_object_counts_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->laser_object_counts(static_cast<int>(i)), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string time_of_day = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->time_of_day().data(), static_cast<int>(this->time_of_day().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.Stats.time_of_day");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->time_of_day(), target);
  }

  // optional string location = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), static_cast<int>(this->location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.Stats.location");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->location(), target);
  }

  // optional string weather = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->weather().data(), static_cast<int>(this->weather().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.Stats.weather");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        4, this->weather(), target);
  }

  // repeated .waymo.open_dataset.Context.Stats.ObjectCount camera_object_counts = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->camera_object_counts_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->camera_object_counts(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.Context.Stats)
  return target;
}

size_t Context_Stats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.Context.Stats)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .waymo.open_dataset.Context.Stats.ObjectCount laser_object_counts = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->laser_object_counts_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->laser_object_counts(static_cast<int>(i)));
    }
  }

  // repeated .waymo.open_dataset.Context.Stats.ObjectCount camera_object_counts = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->camera_object_counts_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->camera_object_counts(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string time_of_day = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->time_of_day());
    }

    // optional string location = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->location());
    }

    // optional string weather = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->weather());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Context_Stats::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.Context.Stats)
  GOOGLE_DCHECK_NE(&from, this);
  const Context_Stats* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Context_Stats>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.Context.Stats)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.Context.Stats)
    MergeFrom(*source);
  }
}

void Context_Stats::MergeFrom(const Context_Stats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.Context.Stats)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  laser_object_counts_.MergeFrom(from.laser_object_counts_);
  camera_object_counts_.MergeFrom(from.camera_object_counts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      time_of_day_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.time_of_day_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      location_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.location_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      weather_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.weather_);
    }
  }
}

void Context_Stats::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.Context.Stats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Context_Stats::CopyFrom(const Context_Stats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.Context.Stats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Context_Stats::IsInitialized() const {
  return true;
}

void Context_Stats::Swap(Context_Stats* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Context_Stats::InternalSwap(Context_Stats* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&laser_object_counts_)->InternalSwap(CastToBase(&other->laser_object_counts_));
  CastToBase(&camera_object_counts_)->InternalSwap(CastToBase(&other->camera_object_counts_));
  time_of_day_.Swap(&other->time_of_day_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  location_.Swap(&other->location_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  weather_.Swap(&other->weather_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata Context_Stats::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Context::InitAsDefaultInstance() {
  ::waymo::open_dataset::_Context_default_instance_._instance.get_mutable()->stats_ = const_cast< ::waymo::open_dataset::Context_Stats*>(
      ::waymo::open_dataset::Context_Stats::internal_default_instance());
}
class Context::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Context>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::waymo::open_dataset::Context_Stats& stats(const Context* msg);
  static void set_has_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::waymo::open_dataset::Context_Stats&
Context::HasBitSetters::stats(const Context* msg) {
  return *msg->stats_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Context::kNameFieldNumber;
const int Context::kCameraCalibrationsFieldNumber;
const int Context::kLaserCalibrationsFieldNumber;
const int Context::kStatsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Context::Context()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.Context)
}
Context::Context(const Context& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      camera_calibrations_(from.camera_calibrations_),
      laser_calibrations_(from.laser_calibrations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_stats()) {
    stats_ = new ::waymo::open_dataset::Context_Stats(*from.stats_);
  } else {
    stats_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.Context)
}

void Context::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  stats_ = nullptr;
}

Context::~Context() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.Context)
  SharedDtor();
}

void Context::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete stats_;
}

void Context::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Context& Context::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Context_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void Context::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.Context)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  camera_calibrations_.Clear();
  laser_calibrations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(stats_ != nullptr);
      stats_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Context::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "waymo.open_dataset.Context.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.CameraCalibration camera_calibrations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_camera_calibrations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.LaserCalibration laser_calibrations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_laser_calibrations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.Context.Stats stats = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_stats(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Context::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.Context)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "waymo.open_dataset.Context.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.CameraCalibration camera_calibrations = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_camera_calibrations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.LaserCalibration laser_calibrations = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_laser_calibrations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.Context.Stats stats = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_stats()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.Context)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.Context)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Context::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.Context)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated .waymo.open_dataset.CameraCalibration camera_calibrations = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->camera_calibrations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->camera_calibrations(static_cast<int>(i)),
      output);
  }

  // repeated .waymo.open_dataset.LaserCalibration laser_calibrations = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->laser_calibrations_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->laser_calibrations(static_cast<int>(i)),
      output);
  }

  // optional .waymo.open_dataset.Context.Stats stats = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::stats(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.Context)
}

::PROTOBUF_NAMESPACE_ID::uint8* Context::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.Context)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "waymo.open_dataset.Context.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // repeated .waymo.open_dataset.CameraCalibration camera_calibrations = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->camera_calibrations_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->camera_calibrations(static_cast<int>(i)), target);
  }

  // repeated .waymo.open_dataset.LaserCalibration laser_calibrations = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->laser_calibrations_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->laser_calibrations(static_cast<int>(i)), target);
  }

  // optional .waymo.open_dataset.Context.Stats stats = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::stats(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.Context)
  return target;
}

size_t Context::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.Context)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .waymo.open_dataset.CameraCalibration camera_calibrations = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->camera_calibrations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->camera_calibrations(static_cast<int>(i)));
    }
  }

  // repeated .waymo.open_dataset.LaserCalibration laser_calibrations = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->laser_calibrations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->laser_calibrations(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .waymo.open_dataset.Context.Stats stats = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stats_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Context::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.Context)
  GOOGLE_DCHECK_NE(&from, this);
  const Context* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Context>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.Context)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.Context)
    MergeFrom(*source);
  }
}

void Context::MergeFrom(const Context& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.Context)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  camera_calibrations_.MergeFrom(from.camera_calibrations_);
  laser_calibrations_.MergeFrom(from.laser_calibrations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_stats()->::waymo::open_dataset::Context_Stats::MergeFrom(from.stats());
    }
  }
}

void Context::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.Context)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Context::CopyFrom(const Context& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.Context)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Context::IsInitialized() const {
  return true;
}

void Context::Swap(Context* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Context::InternalSwap(Context* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&camera_calibrations_)->InternalSwap(CastToBase(&other->camera_calibrations_));
  CastToBase(&laser_calibrations_)->InternalSwap(CastToBase(&other->laser_calibrations_));
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(stats_, other->stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Context::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RangeImage::InitAsDefaultInstance() {
  ::waymo::open_dataset::_RangeImage_default_instance_._instance.get_mutable()->range_image_ = const_cast< ::waymo::open_dataset::MatrixFloat*>(
      ::waymo::open_dataset::MatrixFloat::internal_default_instance());
}
class RangeImage::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<RangeImage>()._has_bits_);
  static void set_has_range_image_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_camera_projection_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_range_image_pose_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::waymo::open_dataset::MatrixFloat& range_image(const RangeImage* msg);
  static void set_has_range_image(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::waymo::open_dataset::MatrixFloat&
RangeImage::HasBitSetters::range_image(const RangeImage* msg) {
  return *msg->range_image_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RangeImage::kRangeImageCompressedFieldNumber;
const int RangeImage::kCameraProjectionCompressedFieldNumber;
const int RangeImage::kRangeImagePoseCompressedFieldNumber;
const int RangeImage::kRangeImageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RangeImage::RangeImage()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.RangeImage)
}
RangeImage::RangeImage(const RangeImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  range_image_compressed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_range_image_compressed()) {
    range_image_compressed_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.range_image_compressed_);
  }
  camera_projection_compressed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_camera_projection_compressed()) {
    camera_projection_compressed_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.camera_projection_compressed_);
  }
  range_image_pose_compressed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_range_image_pose_compressed()) {
    range_image_pose_compressed_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.range_image_pose_compressed_);
  }
  if (from.has_range_image()) {
    range_image_ = new ::waymo::open_dataset::MatrixFloat(*from.range_image_);
  } else {
    range_image_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.RangeImage)
}

void RangeImage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  range_image_compressed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  camera_projection_compressed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  range_image_pose_compressed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  range_image_ = nullptr;
}

RangeImage::~RangeImage() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.RangeImage)
  SharedDtor();
}

void RangeImage::SharedDtor() {
  range_image_compressed_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  camera_projection_compressed_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  range_image_pose_compressed_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete range_image_;
}

void RangeImage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RangeImage& RangeImage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RangeImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void RangeImage::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.RangeImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      range_image_compressed_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      camera_projection_compressed_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      range_image_pose_compressed_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(range_image_ != nullptr);
      range_image_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RangeImage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.MatrixFloat range_image = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_range_image(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes range_image_compressed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_range_image_compressed(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes camera_projection_compressed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_camera_projection_compressed(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes range_image_pose_compressed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_range_image_pose_compressed(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RangeImage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.RangeImage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.MatrixFloat range_image = 1 [deprecated = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_range_image()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes range_image_compressed = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_range_image_compressed()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes camera_projection_compressed = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_camera_projection_compressed()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes range_image_pose_compressed = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_range_image_pose_compressed()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.RangeImage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.RangeImage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RangeImage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.RangeImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.MatrixFloat range_image = 1 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::range_image(this), output);
  }

  // optional bytes range_image_compressed = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->range_image_compressed(), output);
  }

  // optional bytes camera_projection_compressed = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->camera_projection_compressed(), output);
  }

  // optional bytes range_image_pose_compressed = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->range_image_pose_compressed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.RangeImage)
}

::PROTOBUF_NAMESPACE_ID::uint8* RangeImage::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.RangeImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.MatrixFloat range_image = 1 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::range_image(this), target);
  }

  // optional bytes range_image_compressed = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->range_image_compressed(), target);
  }

  // optional bytes camera_projection_compressed = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->camera_projection_compressed(), target);
  }

  // optional bytes range_image_pose_compressed = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        4, this->range_image_pose_compressed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.RangeImage)
  return target;
}

size_t RangeImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.RangeImage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes range_image_compressed = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->range_image_compressed());
    }

    // optional bytes camera_projection_compressed = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->camera_projection_compressed());
    }

    // optional bytes range_image_pose_compressed = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->range_image_pose_compressed());
    }

    // optional .waymo.open_dataset.MatrixFloat range_image = 1 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *range_image_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RangeImage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.RangeImage)
  GOOGLE_DCHECK_NE(&from, this);
  const RangeImage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RangeImage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.RangeImage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.RangeImage)
    MergeFrom(*source);
  }
}

void RangeImage::MergeFrom(const RangeImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.RangeImage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      range_image_compressed_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.range_image_compressed_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      camera_projection_compressed_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.camera_projection_compressed_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      range_image_pose_compressed_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.range_image_pose_compressed_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_range_image()->::waymo::open_dataset::MatrixFloat::MergeFrom(from.range_image());
    }
  }
}

void RangeImage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.RangeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeImage::CopyFrom(const RangeImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.RangeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeImage::IsInitialized() const {
  return true;
}

void RangeImage::Swap(RangeImage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeImage::InternalSwap(RangeImage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  range_image_compressed_.Swap(&other->range_image_compressed_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  camera_projection_compressed_.Swap(&other->camera_projection_compressed_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  range_image_pose_compressed_.Swap(&other->range_image_pose_compressed_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(range_image_, other->range_image_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeImage::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CameraImage::InitAsDefaultInstance() {
  ::waymo::open_dataset::_CameraImage_default_instance_._instance.get_mutable()->pose_ = const_cast< ::waymo::open_dataset::Transform*>(
      ::waymo::open_dataset::Transform::internal_default_instance());
  ::waymo::open_dataset::_CameraImage_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::waymo::open_dataset::Velocity*>(
      ::waymo::open_dataset::Velocity::internal_default_instance());
}
class CameraImage::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<CameraImage>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::waymo::open_dataset::Transform& pose(const CameraImage* msg);
  static void set_has_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::waymo::open_dataset::Velocity& velocity(const CameraImage* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pose_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shutter(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_camera_trigger_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_camera_readout_done_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::waymo::open_dataset::Transform&
CameraImage::HasBitSetters::pose(const CameraImage* msg) {
  return *msg->pose_;
}
const ::waymo::open_dataset::Velocity&
CameraImage::HasBitSetters::velocity(const CameraImage* msg) {
  return *msg->velocity_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CameraImage::kNameFieldNumber;
const int CameraImage::kImageFieldNumber;
const int CameraImage::kPoseFieldNumber;
const int CameraImage::kVelocityFieldNumber;
const int CameraImage::kPoseTimestampFieldNumber;
const int CameraImage::kShutterFieldNumber;
const int CameraImage::kCameraTriggerTimeFieldNumber;
const int CameraImage::kCameraReadoutDoneTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CameraImage::CameraImage()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.CameraImage)
}
CameraImage::CameraImage(const CameraImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  image_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_image()) {
    image_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.image_);
  }
  if (from.has_pose()) {
    pose_ = new ::waymo::open_dataset::Transform(*from.pose_);
  } else {
    pose_ = nullptr;
  }
  if (from.has_velocity()) {
    velocity_ = new ::waymo::open_dataset::Velocity(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  ::memcpy(&pose_timestamp_, &from.pose_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&name_) -
    reinterpret_cast<char*>(&pose_timestamp_)) + sizeof(name_));
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.CameraImage)
}

void CameraImage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  image_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&name_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(name_));
}

CameraImage::~CameraImage() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.CameraImage)
  SharedDtor();
}

void CameraImage::SharedDtor() {
  image_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete velocity_;
}

void CameraImage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CameraImage& CameraImage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CameraImage_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void CameraImage::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.CameraImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      image_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pose_ != nullptr);
      pose_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(velocity_ != nullptr);
      velocity_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&pose_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&name_) -
        reinterpret_cast<char*>(&pose_timestamp_)) + sizeof(name_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CameraImage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.CameraName.Name name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::waymo::open_dataset::CameraName_Name_IsValid(val))) {
            set_name(static_cast<::waymo::open_dataset::CameraName_Name>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_image(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.Transform pose = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.Velocity velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double pose_timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          HasBitSetters::set_has_pose_timestamp(&has_bits);
          pose_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double shutter = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          HasBitSetters::set_has_shutter(&has_bits);
          shutter_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double camera_trigger_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          HasBitSetters::set_has_camera_trigger_time(&has_bits);
          camera_trigger_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double camera_readout_done_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          HasBitSetters::set_has_camera_readout_done_time(&has_bits);
          camera_readout_done_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CameraImage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.CameraImage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.CameraName.Name name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::waymo::open_dataset::CameraName_Name_IsValid(value)) {
            set_name(static_cast< ::waymo::open_dataset::CameraName_Name >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes image = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_image()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.Transform pose = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.Velocity velocity = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double pose_timestamp = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_pose_timestamp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &pose_timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double shutter = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_shutter(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &shutter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double camera_trigger_time = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (57 & 0xFF)) {
          HasBitSetters::set_has_camera_trigger_time(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &camera_trigger_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double camera_readout_done_time = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (65 & 0xFF)) {
          HasBitSetters::set_has_camera_readout_done_time(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &camera_readout_done_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.CameraImage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.CameraImage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CameraImage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.CameraImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.CameraName.Name name = 1;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->name(), output);
  }

  // optional bytes image = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->image(), output);
  }

  // optional .waymo.open_dataset.Transform pose = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::pose(this), output);
  }

  // optional .waymo.open_dataset.Velocity velocity = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::velocity(this), output);
  }

  // optional double pose_timestamp = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(5, this->pose_timestamp(), output);
  }

  // optional double shutter = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(6, this->shutter(), output);
  }

  // optional double camera_trigger_time = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(7, this->camera_trigger_time(), output);
  }

  // optional double camera_readout_done_time = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(8, this->camera_readout_done_time(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.CameraImage)
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraImage::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.CameraImage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.CameraName.Name name = 1;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->name(), target);
  }

  // optional bytes image = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->image(), target);
  }

  // optional .waymo.open_dataset.Transform pose = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::pose(this), target);
  }

  // optional .waymo.open_dataset.Velocity velocity = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::velocity(this), target);
  }

  // optional double pose_timestamp = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->pose_timestamp(), target);
  }

  // optional double shutter = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->shutter(), target);
  }

  // optional double camera_trigger_time = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->camera_trigger_time(), target);
  }

  // optional double camera_readout_done_time = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->camera_readout_done_time(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.CameraImage)
  return target;
}

size_t CameraImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.CameraImage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes image = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->image());
    }

    // optional .waymo.open_dataset.Transform pose = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pose_);
    }

    // optional .waymo.open_dataset.Velocity velocity = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

    // optional double pose_timestamp = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double shutter = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double camera_trigger_time = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double camera_readout_done_time = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional .waymo.open_dataset.CameraName.Name name = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->name());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CameraImage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.CameraImage)
  GOOGLE_DCHECK_NE(&from, this);
  const CameraImage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CameraImage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.CameraImage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.CameraImage)
    MergeFrom(*source);
  }
}

void CameraImage::MergeFrom(const CameraImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.CameraImage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      image_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.image_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_pose()->::waymo::open_dataset::Transform::MergeFrom(from.pose());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_velocity()->::waymo::open_dataset::Velocity::MergeFrom(from.velocity());
    }
    if (cached_has_bits & 0x00000008u) {
      pose_timestamp_ = from.pose_timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      shutter_ = from.shutter_;
    }
    if (cached_has_bits & 0x00000020u) {
      camera_trigger_time_ = from.camera_trigger_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      camera_readout_done_time_ = from.camera_readout_done_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      name_ = from.name_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CameraImage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.CameraImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraImage::CopyFrom(const CameraImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.CameraImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraImage::IsInitialized() const {
  return true;
}

void CameraImage::Swap(CameraImage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CameraImage::InternalSwap(CameraImage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  image_.Swap(&other->image_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pose_, other->pose_);
  swap(velocity_, other->velocity_);
  swap(pose_timestamp_, other->pose_timestamp_);
  swap(shutter_, other->shutter_);
  swap(camera_trigger_time_, other->camera_trigger_time_);
  swap(camera_readout_done_time_, other->camera_readout_done_time_);
  swap(name_, other->name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraImage::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CameraLabels::InitAsDefaultInstance() {
}
class CameraLabels::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<CameraLabels>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void CameraLabels::clear_labels() {
  labels_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CameraLabels::kNameFieldNumber;
const int CameraLabels::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CameraLabels::CameraLabels()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.CameraLabels)
}
CameraLabels::CameraLabels(const CameraLabels& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      labels_(from.labels_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_ = from.name_;
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.CameraLabels)
}

void CameraLabels::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  name_ = 0;
}

CameraLabels::~CameraLabels() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.CameraLabels)
  SharedDtor();
}

void CameraLabels::SharedDtor() {
}

void CameraLabels::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CameraLabels& CameraLabels::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CameraLabels_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void CameraLabels::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.CameraLabels)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  labels_.Clear();
  name_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CameraLabels::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.CameraName.Name name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::waymo::open_dataset::CameraName_Name_IsValid(val))) {
            set_name(static_cast<::waymo::open_dataset::CameraName_Name>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.Label labels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_labels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CameraLabels::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.CameraLabels)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.CameraName.Name name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::waymo::open_dataset::CameraName_Name_IsValid(value)) {
            set_name(static_cast< ::waymo::open_dataset::CameraName_Name >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.Label labels = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_labels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.CameraLabels)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.CameraLabels)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CameraLabels::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.CameraLabels)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.CameraName.Name name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->name(), output);
  }

  // repeated .waymo.open_dataset.Label labels = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->labels_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->labels(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.CameraLabels)
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraLabels::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.CameraLabels)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.CameraName.Name name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->name(), target);
  }

  // repeated .waymo.open_dataset.Label labels = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->labels_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->labels(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.CameraLabels)
  return target;
}

size_t CameraLabels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.CameraLabels)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .waymo.open_dataset.Label labels = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->labels_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->labels(static_cast<int>(i)));
    }
  }

  // optional .waymo.open_dataset.CameraName.Name name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->name());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CameraLabels::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.CameraLabels)
  GOOGLE_DCHECK_NE(&from, this);
  const CameraLabels* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CameraLabels>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.CameraLabels)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.CameraLabels)
    MergeFrom(*source);
  }
}

void CameraLabels::MergeFrom(const CameraLabels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.CameraLabels)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  labels_.MergeFrom(from.labels_);
  if (from.has_name()) {
    set_name(from.name());
  }
}

void CameraLabels::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.CameraLabels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraLabels::CopyFrom(const CameraLabels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.CameraLabels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraLabels::IsInitialized() const {
  return true;
}

void CameraLabels::Swap(CameraLabels* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CameraLabels::InternalSwap(CameraLabels* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&labels_)->InternalSwap(CastToBase(&other->labels_));
  swap(name_, other->name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraLabels::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Laser::InitAsDefaultInstance() {
  ::waymo::open_dataset::_Laser_default_instance_._instance.get_mutable()->ri_return1_ = const_cast< ::waymo::open_dataset::RangeImage*>(
      ::waymo::open_dataset::RangeImage::internal_default_instance());
  ::waymo::open_dataset::_Laser_default_instance_._instance.get_mutable()->ri_return2_ = const_cast< ::waymo::open_dataset::RangeImage*>(
      ::waymo::open_dataset::RangeImage::internal_default_instance());
}
class Laser::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Laser>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::waymo::open_dataset::RangeImage& ri_return1(const Laser* msg);
  static void set_has_ri_return1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::waymo::open_dataset::RangeImage& ri_return2(const Laser* msg);
  static void set_has_ri_return2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::waymo::open_dataset::RangeImage&
Laser::HasBitSetters::ri_return1(const Laser* msg) {
  return *msg->ri_return1_;
}
const ::waymo::open_dataset::RangeImage&
Laser::HasBitSetters::ri_return2(const Laser* msg) {
  return *msg->ri_return2_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Laser::kNameFieldNumber;
const int Laser::kRiReturn1FieldNumber;
const int Laser::kRiReturn2FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Laser::Laser()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.Laser)
}
Laser::Laser(const Laser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_ri_return1()) {
    ri_return1_ = new ::waymo::open_dataset::RangeImage(*from.ri_return1_);
  } else {
    ri_return1_ = nullptr;
  }
  if (from.has_ri_return2()) {
    ri_return2_ = new ::waymo::open_dataset::RangeImage(*from.ri_return2_);
  } else {
    ri_return2_ = nullptr;
  }
  name_ = from.name_;
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.Laser)
}

void Laser::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  ::memset(&ri_return1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&name_) -
      reinterpret_cast<char*>(&ri_return1_)) + sizeof(name_));
}

Laser::~Laser() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.Laser)
  SharedDtor();
}

void Laser::SharedDtor() {
  if (this != internal_default_instance()) delete ri_return1_;
  if (this != internal_default_instance()) delete ri_return2_;
}

void Laser::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Laser& Laser::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Laser_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void Laser::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.Laser)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(ri_return1_ != nullptr);
      ri_return1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(ri_return2_ != nullptr);
      ri_return2_->Clear();
    }
  }
  name_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Laser::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.LaserName.Name name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::waymo::open_dataset::LaserName_Name_IsValid(val))) {
            set_name(static_cast<::waymo::open_dataset::LaserName_Name>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.RangeImage ri_return1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_ri_return1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.RangeImage ri_return2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_ri_return2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Laser::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.Laser)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.LaserName.Name name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::waymo::open_dataset::LaserName_Name_IsValid(value)) {
            set_name(static_cast< ::waymo::open_dataset::LaserName_Name >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.RangeImage ri_return1 = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_ri_return1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.RangeImage ri_return2 = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_ri_return2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.Laser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.Laser)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Laser::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.Laser)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.LaserName.Name name = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->name(), output);
  }

  // optional .waymo.open_dataset.RangeImage ri_return1 = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::ri_return1(this), output);
  }

  // optional .waymo.open_dataset.RangeImage ri_return2 = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::ri_return2(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.Laser)
}

::PROTOBUF_NAMESPACE_ID::uint8* Laser::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.Laser)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.LaserName.Name name = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->name(), target);
  }

  // optional .waymo.open_dataset.RangeImage ri_return1 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::ri_return1(this), target);
  }

  // optional .waymo.open_dataset.RangeImage ri_return2 = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::ri_return2(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.Laser)
  return target;
}

size_t Laser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.Laser)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .waymo.open_dataset.RangeImage ri_return1 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ri_return1_);
    }

    // optional .waymo.open_dataset.RangeImage ri_return2 = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ri_return2_);
    }

    // optional .waymo.open_dataset.LaserName.Name name = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->name());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Laser::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.Laser)
  GOOGLE_DCHECK_NE(&from, this);
  const Laser* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Laser>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.Laser)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.Laser)
    MergeFrom(*source);
  }
}

void Laser::MergeFrom(const Laser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.Laser)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_ri_return1()->::waymo::open_dataset::RangeImage::MergeFrom(from.ri_return1());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_ri_return2()->::waymo::open_dataset::RangeImage::MergeFrom(from.ri_return2());
    }
    if (cached_has_bits & 0x00000004u) {
      name_ = from.name_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Laser::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.Laser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Laser::CopyFrom(const Laser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.Laser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Laser::IsInitialized() const {
  return true;
}

void Laser::Swap(Laser* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Laser::InternalSwap(Laser* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(ri_return1_, other->ri_return1_);
  swap(ri_return2_, other->ri_return2_);
  swap(name_, other->name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Laser::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Frame::InitAsDefaultInstance() {
  ::waymo::open_dataset::_Frame_default_instance_._instance.get_mutable()->context_ = const_cast< ::waymo::open_dataset::Context*>(
      ::waymo::open_dataset::Context::internal_default_instance());
  ::waymo::open_dataset::_Frame_default_instance_._instance.get_mutable()->pose_ = const_cast< ::waymo::open_dataset::Transform*>(
      ::waymo::open_dataset::Transform::internal_default_instance());
}
class Frame::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Frame>()._has_bits_);
  static const ::waymo::open_dataset::Context& context(const Frame* msg);
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::waymo::open_dataset::Transform& pose(const Frame* msg);
  static void set_has_pose(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::waymo::open_dataset::Context&
Frame::HasBitSetters::context(const Frame* msg) {
  return *msg->context_;
}
const ::waymo::open_dataset::Transform&
Frame::HasBitSetters::pose(const Frame* msg) {
  return *msg->pose_;
}
void Frame::clear_laser_labels() {
  laser_labels_.Clear();
}
void Frame::clear_no_label_zones() {
  no_label_zones_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame::kContextFieldNumber;
const int Frame::kTimestampMicrosFieldNumber;
const int Frame::kPoseFieldNumber;
const int Frame::kImagesFieldNumber;
const int Frame::kLasersFieldNumber;
const int Frame::kLaserLabelsFieldNumber;
const int Frame::kProjectedLidarLabelsFieldNumber;
const int Frame::kCameraLabelsFieldNumber;
const int Frame::kNoLabelZonesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame::Frame()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:waymo.open_dataset.Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      images_(from.images_),
      lasers_(from.lasers_),
      laser_labels_(from.laser_labels_),
      no_label_zones_(from.no_label_zones_),
      camera_labels_(from.camera_labels_),
      projected_lidar_labels_(from.projected_lidar_labels_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_context()) {
    context_ = new ::waymo::open_dataset::Context(*from.context_);
  } else {
    context_ = nullptr;
  }
  if (from.has_pose()) {
    pose_ = new ::waymo::open_dataset::Transform(*from.pose_);
  } else {
    pose_ = nullptr;
  }
  timestamp_micros_ = from.timestamp_micros_;
  // @@protoc_insertion_point(copy_constructor:waymo.open_dataset.Frame)
}

void Frame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Frame_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  ::memset(&context_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&timestamp_micros_) -
      reinterpret_cast<char*>(&context_)) + sizeof(timestamp_micros_));
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:waymo.open_dataset.Frame)
  SharedDtor();
}

void Frame::SharedDtor() {
  if (this != internal_default_instance()) delete context_;
  if (this != internal_default_instance()) delete pose_;
}

void Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Frame& Frame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Frame_waymo_5fopen_5fdataset_2fdataset_2eproto.base);
  return *internal_default_instance();
}


void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:waymo.open_dataset.Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  images_.Clear();
  lasers_.Clear();
  laser_labels_.Clear();
  no_label_zones_.Clear();
  camera_labels_.Clear();
  projected_lidar_labels_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(context_ != nullptr);
      context_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pose_ != nullptr);
      pose_->Clear();
    }
  }
  timestamp_micros_ = PROTOBUF_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Frame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .waymo.open_dataset.Context context = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_context(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 timestamp_micros = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_timestamp_micros(&has_bits);
          timestamp_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .waymo.open_dataset.Transform pose = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_pose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.CameraImage images = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_images(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.Laser lasers = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_lasers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.Label laser_labels = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_laser_labels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 50);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.Polygon2dProto no_label_zones = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_no_label_zones(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 58);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.CameraLabels camera_labels = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_camera_labels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 66);
        } else goto handle_unusual;
        continue;
      // repeated .waymo.open_dataset.CameraLabels projected_lidar_labels = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_projected_lidar_labels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 74);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Frame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:waymo.open_dataset.Frame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .waymo.open_dataset.Context context = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_context()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 timestamp_micros = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_timestamp_micros(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_micros_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .waymo.open_dataset.Transform pose = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.CameraImage images = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_images()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.Laser lasers = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_lasers()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.Label laser_labels = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_laser_labels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.Polygon2dProto no_label_zones = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_no_label_zones()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.CameraLabels camera_labels = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_camera_labels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .waymo.open_dataset.CameraLabels projected_lidar_labels = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_projected_lidar_labels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:waymo.open_dataset.Frame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:waymo.open_dataset.Frame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Frame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:waymo.open_dataset.Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.Context context = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::context(this), output);
  }

  // optional int64 timestamp_micros = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->timestamp_micros(), output);
  }

  // optional .waymo.open_dataset.Transform pose = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::pose(this), output);
  }

  // repeated .waymo.open_dataset.CameraImage images = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->images_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->images(static_cast<int>(i)),
      output);
  }

  // repeated .waymo.open_dataset.Laser lasers = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->lasers_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->lasers(static_cast<int>(i)),
      output);
  }

  // repeated .waymo.open_dataset.Label laser_labels = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->laser_labels_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6,
      this->laser_labels(static_cast<int>(i)),
      output);
  }

  // repeated .waymo.open_dataset.Polygon2dProto no_label_zones = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->no_label_zones_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      7,
      this->no_label_zones(static_cast<int>(i)),
      output);
  }

  // repeated .waymo.open_dataset.CameraLabels camera_labels = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->camera_labels_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      8,
      this->camera_labels(static_cast<int>(i)),
      output);
  }

  // repeated .waymo.open_dataset.CameraLabels projected_lidar_labels = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projected_lidar_labels_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      9,
      this->projected_lidar_labels(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:waymo.open_dataset.Frame)
}

::PROTOBUF_NAMESPACE_ID::uint8* Frame::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:waymo.open_dataset.Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .waymo.open_dataset.Context context = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::context(this), target);
  }

  // optional int64 timestamp_micros = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->timestamp_micros(), target);
  }

  // optional .waymo.open_dataset.Transform pose = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::pose(this), target);
  }

  // repeated .waymo.open_dataset.CameraImage images = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->images_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->images(static_cast<int>(i)), target);
  }

  // repeated .waymo.open_dataset.Laser lasers = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->lasers_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->lasers(static_cast<int>(i)), target);
  }

  // repeated .waymo.open_dataset.Label laser_labels = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->laser_labels_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->laser_labels(static_cast<int>(i)), target);
  }

  // repeated .waymo.open_dataset.Polygon2dProto no_label_zones = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->no_label_zones_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->no_label_zones(static_cast<int>(i)), target);
  }

  // repeated .waymo.open_dataset.CameraLabels camera_labels = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->camera_labels_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, this->camera_labels(static_cast<int>(i)), target);
  }

  // repeated .waymo.open_dataset.CameraLabels projected_lidar_labels = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->projected_lidar_labels_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, this->projected_lidar_labels(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:waymo.open_dataset.Frame)
  return target;
}

size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:waymo.open_dataset.Frame)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .waymo.open_dataset.CameraImage images = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->images_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->images(static_cast<int>(i)));
    }
  }

  // repeated .waymo.open_dataset.Laser lasers = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->lasers_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->lasers(static_cast<int>(i)));
    }
  }

  // repeated .waymo.open_dataset.Label laser_labels = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->laser_labels_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->laser_labels(static_cast<int>(i)));
    }
  }

  // repeated .waymo.open_dataset.Polygon2dProto no_label_zones = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->no_label_zones_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->no_label_zones(static_cast<int>(i)));
    }
  }

  // repeated .waymo.open_dataset.CameraLabels camera_labels = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->camera_labels_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->camera_labels(static_cast<int>(i)));
    }
  }

  // repeated .waymo.open_dataset.CameraLabels projected_lidar_labels = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->projected_lidar_labels_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->projected_lidar_labels(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .waymo.open_dataset.Context context = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *context_);
    }

    // optional .waymo.open_dataset.Transform pose = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pose_);
    }

    // optional int64 timestamp_micros = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->timestamp_micros());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Frame::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:waymo.open_dataset.Frame)
  GOOGLE_DCHECK_NE(&from, this);
  const Frame* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Frame>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:waymo.open_dataset.Frame)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:waymo.open_dataset.Frame)
    MergeFrom(*source);
  }
}

void Frame::MergeFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:waymo.open_dataset.Frame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  images_.MergeFrom(from.images_);
  lasers_.MergeFrom(from.lasers_);
  laser_labels_.MergeFrom(from.laser_labels_);
  no_label_zones_.MergeFrom(from.no_label_zones_);
  camera_labels_.MergeFrom(from.camera_labels_);
  projected_lidar_labels_.MergeFrom(from.projected_lidar_labels_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_context()->::waymo::open_dataset::Context::MergeFrom(from.context());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_pose()->::waymo::open_dataset::Transform::MergeFrom(from.pose());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_micros_ = from.timestamp_micros_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Frame::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:waymo.open_dataset.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:waymo.open_dataset.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::Swap(Frame* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&images_)->InternalSwap(CastToBase(&other->images_));
  CastToBase(&lasers_)->InternalSwap(CastToBase(&other->lasers_));
  CastToBase(&laser_labels_)->InternalSwap(CastToBase(&other->laser_labels_));
  CastToBase(&no_label_zones_)->InternalSwap(CastToBase(&other->no_label_zones_));
  CastToBase(&camera_labels_)->InternalSwap(CastToBase(&other->camera_labels_));
  CastToBase(&projected_lidar_labels_)->InternalSwap(CastToBase(&other->projected_lidar_labels_));
  swap(context_, other->context_);
  swap(pose_, other->pose_);
  swap(timestamp_micros_, other->timestamp_micros_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Frame::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace open_dataset
}  // namespace waymo
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::MatrixShape* Arena::CreateMaybeMessage< ::waymo::open_dataset::MatrixShape >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::MatrixShape >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::MatrixFloat* Arena::CreateMaybeMessage< ::waymo::open_dataset::MatrixFloat >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::MatrixFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::MatrixInt32* Arena::CreateMaybeMessage< ::waymo::open_dataset::MatrixInt32 >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::MatrixInt32 >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::CameraName* Arena::CreateMaybeMessage< ::waymo::open_dataset::CameraName >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::CameraName >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::LaserName* Arena::CreateMaybeMessage< ::waymo::open_dataset::LaserName >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::LaserName >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::Transform* Arena::CreateMaybeMessage< ::waymo::open_dataset::Transform >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::Transform >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::Velocity* Arena::CreateMaybeMessage< ::waymo::open_dataset::Velocity >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::Velocity >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::CameraCalibration* Arena::CreateMaybeMessage< ::waymo::open_dataset::CameraCalibration >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::CameraCalibration >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::LaserCalibration* Arena::CreateMaybeMessage< ::waymo::open_dataset::LaserCalibration >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::LaserCalibration >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::Context_Stats_ObjectCount* Arena::CreateMaybeMessage< ::waymo::open_dataset::Context_Stats_ObjectCount >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::Context_Stats_ObjectCount >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::Context_Stats* Arena::CreateMaybeMessage< ::waymo::open_dataset::Context_Stats >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::Context_Stats >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::Context* Arena::CreateMaybeMessage< ::waymo::open_dataset::Context >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::Context >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::RangeImage* Arena::CreateMaybeMessage< ::waymo::open_dataset::RangeImage >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::RangeImage >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::CameraImage* Arena::CreateMaybeMessage< ::waymo::open_dataset::CameraImage >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::CameraImage >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::CameraLabels* Arena::CreateMaybeMessage< ::waymo::open_dataset::CameraLabels >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::CameraLabels >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::Laser* Arena::CreateMaybeMessage< ::waymo::open_dataset::Laser >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::Laser >(arena);
}
template<> PROTOBUF_NOINLINE ::waymo::open_dataset::Frame* Arena::CreateMaybeMessage< ::waymo::open_dataset::Frame >(Arena* arena) {
  return Arena::CreateInternal< ::waymo::open_dataset::Frame >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
